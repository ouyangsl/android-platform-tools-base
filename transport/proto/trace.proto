/*
* Copyright (C) 2018 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
syntax = "proto3";

package profiler.proto;
option java_package = "com.android.tools.profiler.proto";
option java_outer_classname = "Trace";

import "protos/perfetto/config/perfetto_config.proto";

// A TraceInfo contains the information regarding a trace
// and should be returned if its time overlaps with the request time range.
message TraceInfo {
  int64 trace_id = 1;
  int64 from_timestamp = 2;  // inclusive
  int64 to_timestamp = 3;    // inclusive
  TraceConfiguration configuration = 4;
  TraceStartStatus start_status = 5;
  TraceStopStatus stop_status = 6;
}

// A TraceData contains a TraceInfo message, wrapped in either
// a TraceStarted or TraceEnded message to indicate whether the
// data is tied to the start or end of a trace. This is the data
// type tied to a cpu and memory trace events.
message TraceData {
  message TraceStarted {
    TraceInfo trace_info = 1;
  }

  message TraceEnded {
    TraceInfo trace_info = 1;
  }

  oneof union {
    TraceStarted trace_started = 1;
    TraceEnded trace_ended = 2;
  }
}

message TraceStartStatus {
  enum Status {
    UNSPECIFIED = 0;
    SUCCESS = 1;
    FAILURE = 2;
  }

  Status status = 1;
  string error_message = 2;
  // The time at which the trace was started (in nanoseconds).
  int64 start_time_ns = 3;
}

message TraceStopStatus {
  enum Status {
    UNSPECIFIED = 0;
    SUCCESS = 1;
    NO_ONGOING_PROFILING = 2;
    APP_PROCESS_DIED = 3;
    APP_PID_CHANGED = 4;
    PROFILER_PROCESS_DIED = 5;
    STOP_COMMAND_FAILED = 6;
    STILL_PROFILING_AFTER_STOP = 7;
    CANNOT_START_WAITING = 8;
    WAIT_TIMEOUT = 9;
    WAIT_FAILED = 10;
    CANNOT_READ_WAIT_EVENT = 11;
    CANNOT_COPY_FILE = 12;
    CANNOT_FORM_FILE = 13;
    CANNOT_READ_FILE = 14;
    // Generic failure status for non-defined failures.
    OTHER_FAILURE = 15;
  }

  Status status = 1;
  string error_message = 2;
  // The time taken (i.e. elapsed duration) to stop the trace (in nanoseconds).
  int64 stopping_duration_ns = 3;
}


message TraceStatusData {
  oneof union {
    TraceStartStatus trace_start_status = 1;
    TraceStopStatus trace_stop_status = 2;
  }
}

enum TraceMode {
  UNSPECIFIED_MODE = 0;
  SAMPLED = 1;
  INSTRUMENTED = 2;
}

enum TraceInitiationType {
  UNSPECIFIED_INITIATION = 0;
  INITIATED_BY_UI = 1;  // specifically means non-startup UI operations.
  INITIATED_BY_API = 2;
  INITIATED_BY_STARTUP = 3;
}

// The configuration for taking a trace. This includes configuration information
// specific to one tracing technology out of Art, Atrace, Simpleperf, and Perfetto.
// Along with that comes configuration information that is agnostic of the technology
// used such as the path to the trace file produced.
message TraceConfiguration {
  // The name of the app to be traced. Most if not all trace modes supports the
  // app_name as the input instead pid. In the case of startup profiling, we
  // don't know the pid anyway, so we use the app's name for all scenarios
  // instead.
  string app_name = 1;

  // ABI CPU architecture of the simpleperf/perfetto binary to use. This
  // should match the arch of the device and should be one of the
  // values defined by SdkConstants.CPU_ARCH_*, e.g. 'arm', 'arm64', 'x86'.
  string abi_cpu_arch = 2;

  // The device path to output the trace to. Generated by Studio unless for the
  // case of initiation_type == |INITIATED_BY_API| which does not need to
  // specify a path. Note that this is a only for temp storage. A completed
  // trace will be made available via the |GetBytes| rpc using the trace id as
  // the byte's id.
  string temp_path = 3;

  // The method in which the trace was initiated. This is needed to tell if
  // tracing was initiated via API, UI, or on startup as the trace configuration
  // will be handled differently for the respective initiation type.
  TraceInitiationType initiation_type = 4;

  // One option field will be set depending on the type of technology used for the trace.
  // These options have all the fields/data needed for the respective technology.
  oneof union {
    ArtOptions art_options = 5;
    AtraceOptions atrace_options = 6;
    SimpleperfOptions simpleperf_options = 7;
    // Utilizes Perfetto's defined TraceConfig proto
    perfetto.protos.TraceConfig perfetto_options = 8;
  }
}

// The options for a Simpleperf-based trace.
message SimpleperfOptions {
  // When using sampling, the sampling interval in microseconds.
  int32 sampling_interval_us = 1;

  // The host path to symbols for this trace. This is passed in by studio
  // and used by the simpleperf preprocessor to properly symbolize the trace.
  // The symbolized trace is then saved in the datastore.
  repeated string symbol_dirs = 2;
}

// The options for a Atrace-based trace.
message AtraceOptions {
  // The size of the buffer that holds tracing data.
  int32 buffer_size_in_mb = 1;
}

// The options for a Art-based trace.
message ArtOptions {
  // When using sampling, the sampling interval in microseconds.
  int32 sampling_interval_us = 1;

  // The size of the buffer that holds tracing data.
  int32 buffer_size_in_mb = 2;

  // The mode of tracing can be either sampled or instrumented.
  // Art-based traces can be either.
  TraceMode trace_mode = 3;
}

// The profiler type of trace being taken. Used to differentiate
// between start/stop trace command sources and determine the
// correct respective trace event kind to send.
// TODO (b/263903182): Refactor studio & base side to have start/stop
// trace commands be ProfilerType-agnostic.
enum ProfilerType {
  UNSPECIFIED = 0;
  CPU = 1;
  MEMORY = 2;
}

// The command to initiate a trace/capture. 
// It contains metadata for api initiated tracing and configuration 
// information for the trace to be captured. 
message StartTrace {
  // Agent is responsible for providing these additional info for API-
  // initiated tracing.
  message ApiStartTracingMetaData {
    int64 start_timestamp = 1;
  }
  TraceConfiguration configuration = 1;
  // Set only if configuration's initiation_type is |INITIATED_BY_API|.
  ApiStartTracingMetaData api_start_metadata = 2;
  // Set to identify which profiler will initiates this command.
  ProfilerType profiler_type = 4;
}

// The command to terminate an ongoing trace/capture. 
// It contains metadata for api initiated tracing and configuration 
// information for the ongoing capture it is sent to terminate.
message StopTrace {
  // Agent is responsible for providing these additional info for API-
  // initiated tracing.
  message ApiStopTracingMetaData {
    int64 stop_timestamp = 1;
    // A name of trace's content that's unique during the lifetime of the
    // process. The daemon is responsible for storing the content in the generic
    // cache that can be referenced via the trace's id.
    string trace_name = 2;
  }
  TraceConfiguration configuration = 1;
  // Set only if configuration's initiation_type is |INITIATED_BY_API|.
  ApiStopTracingMetaData api_stop_metadata = 2;
  // Whether the command needs to wait and parse the trace content.
  bool need_trace_response = 3;
  // Set to identify which profiler initiates this command.
  ProfilerType profiler_type = 4;
}