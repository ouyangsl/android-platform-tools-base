/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Note: this file must be kept in sync with
// /system/extra/simpleperf/cmd_report_sample.proto
// The current version is based on
// https://android.googlesource.com/platform/system/extras/+/be5fd2943287b6aa642c3b1c42d4a8a08dc8d417/simpleperf/cmd_report_sample.proto
// [by Android Studio team]

// The file format generated by cmd_report_sample.proto is as below:
// char magic[10] = "SIMPLEPERF";
// LittleEndian16(version) = 1;
// LittleEndian32(record_size_0)
// message Record(record_0) (having record_size_0 bytes)
// LittleEndian32(record_size_1)
// message Record(record_1) (having record_size_1 bytes)
// ...
// LittleEndian32(record_size_N)
// message Record(record_N) (having record_size_N bytes)
// LittleEndian32(0)

// Simpleperf's copy uses proto2. [by Android Studio team]
syntax = "proto3";

option optimize_for = LITE_RUNTIME;
package simpleperf_report_proto;
option java_package = "com.android.tools.profiler.proto";
option java_outer_classname = "SimpleperfReport";

message Sample {
  // Exceptionally allow unsigned since this proto is from simpleperf. Same
  // applies to other unsigned fields. [by Android Studio team]
  //
  // Monotonic clock time in nanoseconds. On kernel < 4.1, it's perf clock instead.
  uint64 time = 1;
  int32 thread_id = 2;

  message CallChainEntry {
    // virtual address of the instruction in elf file
    uint64 vaddr_in_file = 1;

    // index of the elf file containing the instruction
    uint32 file_id = 2;

    // symbol_id refers to the name of the function containing the instruction.
    // If the function name is found, it is a valid index in the symbol table
    // of File with 'id' field being file_id, otherwise it is -1.
    int32 symbol_id = 3;

    enum ExecutionType {
      // methods belong to native libraries, AOT compiled JVM code and ART methods not used near
      // JVM methods
      NATIVE_METHOD = 0;
      INTERPRETED_JVM_METHOD = 1;
      JIT_JVM_METHOD = 2;
      // ART methods used near JVM methods. It's shown only when --show-art-frames is used.
      ART_METHOD = 3;
    }
    // Simpleperf's copy of the following line contains
    // "[default = NATIVE_METHOD]" but it breaks Android Studio build because
    // "Explicit default values are not allowed in proto3". [by Android Studio team]
    ExecutionType execution_type = 4;
  }

  // Sampled call chain ordered from the leaf to the root. [by Android Studio team]
  repeated CallChainEntry callchain = 3;

  // Simpleperf generates one sample whenever a specified amount of events happen
  // while running a monitored thread. So each sample belongs to one event type.
  // Event type can be cpu-cycles, cpu-clock, sched:sched_switch or other types.
  // By using '-e' option, we can ask simpleperf to record samples for one or more
  // event types.
  // Each event type generates samples independently. But recording more event types
  // will cost more cpu time generating samples, which may affect the monitored threads
  // and sample lost rate.
  // event_count field shows the count of the events (belong to the sample's event type)
  // that have happened since last sample (belong to the sample's event type) for the
  // same thread. However, if there are lost samples between current sample and previous
  // sample, the event_count is the count of events from the last lost sample.
  uint64 event_count = 4;

  // An index in meta_info.event_type, shows which event type current sample belongs to.
  uint32 event_type_id = 5;

  message UnwindingResult {
    // error code provided by libunwindstack, in
    // https://cs.android.com/android/platform/superproject/+/master:system/unwinding/libunwindstack/include/unwindstack/Error.h
    uint32 raw_error_code = 1;
    // error addr provided by libunwindstack
    uint64 error_addr = 2;

    // error code interpreted by simpleperf
    enum ErrorCode {
      ERROR_NONE = 0;                  // No error
      ERROR_UNKNOWN = 1;               // Error not interpreted by simpleperf, see raw_error_code
      ERROR_NOT_ENOUGH_STACK = 2;      // Simpleperf doesn't record enough stack data
      ERROR_MEMORY_INVALID = 3;        // Memory read failed
      ERROR_UNWIND_INFO = 4;           // No debug info in binary to support unwinding
      ERROR_INVALID_MAP = 5;           // Unwind in an invalid map
      ERROR_MAX_FRAME_EXCEEDED = 6;    // Stopped at MAX_UNWINDING_FRAMES, which is 512.
      ERROR_REPEATED_FRAME = 7;        // The last frame has the same pc/sp as the next.
      ERROR_INVALID_ELF = 8;           // Unwind in an invalid elf file
    }
    ErrorCode error_code = 3;
  }

  // Unwinding result is provided for samples without a complete callchain, when recorded with
  // --keep-failed-unwinding-result or --keep-failed-unwinding-debug-info.
  UnwindingResult unwinding_result = 6;
}

message LostSituation {
  uint64 sample_count = 1;
  uint64 lost_count = 2;
}

message File {
  // unique id for each file, starting from 0, and add 1 each time.
  uint32 id = 1;

  // file path, like /system/lib/libc.so.
  string path = 2;

  // symbol table of the file.
  repeated string symbol = 3;

  // mangled symbol table of the file.
  repeated string mangled_symbol = 4;
}

message Thread {
  uint32 thread_id = 1;
  uint32 process_id = 2;
  string thread_name = 3;
}

message MetaInfo {
  repeated string event_type = 1;
  string app_package_name = 2;
  string app_type = 3;  // debuggable, profileable or non_profileable
  string android_sdk_version = 4;
  string android_build_type = 5;  // user, userdebug or eng

  // True if the profile is recorded with --trace-offcpu option.
  bool trace_offcpu = 6;
}

// Thread context switch info. It is available when MetaInfo.trace_offcpu = true.
message ContextSwitch {
  // If true, the thread is scheduled on cpu, otherwise it is scheduled off cpu.
  bool switch_on = 1;

  // Monotonic clock time in nanoseconds. On kernel < 4.1, it's perf clock instead.
  uint64 time = 2;
  uint32 thread_id = 3;
}

message Record {
  oneof record_data {
    Sample sample = 1;
    LostSituation lost = 2;
    File file = 3;
    Thread thread = 4;
    MetaInfo meta_info = 5;
    ContextSwitch context_switch = 6;
  }
}